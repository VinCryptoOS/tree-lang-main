1. Длинные понятные сообщения об ошибках, которые могут использоваться как мнемоника констант
Причём эта мнемоника должна совпадать, если используется экспорт dll
    и там те же строки могут быть определены как другие числовые константы

    Т.е. типы-перечисления должны быть с понятными и длинными именами, которые согласуются между проектами

2. Беспорядочный порядок выполнения: вложенная функция может давать команду на выход из основной функции
(программирование в стиле if return)

3. Нетипизированные структуры, которые типизирует либо сам программист,
либо типизируются по дополнительным служебным кодам, которые выдаёт функция, их возвращающая
Типизированные классы, позволяющие виртуальные функции и т.п.
Виртуальные функции, кстати, могут быть и без наследования? Нет, кажется, не могут быть
    При работе с нетипизированными структурами, возможно, стоит учесть типизацию в массивах структур
    В том числе, типизация должна быть
        логически точная
        точная (один и тот же физический тип) - допускаются логические приведения (алиасы одного и того же типа)
        неточная (с приведением типов)
    Типизационные метки!

    То есть структура может быть
        Логически типизированная + типизированная флагами
        Типизированная (номер типа)
        Защищённая (указатель на структуру содержит специальное защитное число)
        Перемещаемая - доступ к объекту может быть
                         только если объект не перемещается для дефрагментации памяти

    volatile - структура, которая при каждом к ней доступе должна производить полную проверку защиты
    volatile - это свойство типа

    Указатели: копия и оригинал.

    Структура одного и того же типа может быть:
        Принудительно типизированная - не допускается удалять типизацию/защиту
        По-умолчанию типизированная - типизация есть по-умолчанию
        И по-умолчанию не типизированная

    3.1. Таким образом, структура может содержать следующие вспомогательные поля:
        1. Номер типа + в старших 3-х байтах набор флагов
            Флаги:
                1. логически типизированная
                2. защищённая
                3. перемещаемая
                4. volatile (изменяемая между потоками)
                5. Содежит дополнительный описатель типов
                6. Содержит дополнительный описатель многопоточных блокировок
                7. Содержит дополнительные описатели типизационных меток-битов
                8. Флаг "копия логически удалена из памяти"
                1. Только для чтения
                2. Не допускается копирование с временем жизни больше, чем до возврата из функции
                3. Содержит счётчик ссылок
                4-5.
                    0. Не автоматически удаляемая
                    1. Автоматически удаляемая по счётчику ссылок
                    2. Автоматически удаляемая при удалении родительского объекта (содержит на него указатель)
                    3. --
                6. Имеется ли хотя бы одно доп. поле
                7. В списке дефрагментации (но не обязательно, что перемещаемая)
                8. Имеет доп. защитный код, указывающий, что она участвует в операциях ТОЛЬКО по этому коду
                1. Необходимо обнуление при удалении или перемещении. Если объект типизированный, то перезапись проводится значениями, указанными в типе объекта
                2. Спец. тип. Необходимы иные проверки. Читать информацию в типе
        2. Коды для доступа к дополнительным полям, если имеется хотя бы одно дополнительное поле
            (каждый байт описывает, по какому смещению находится доп. поле)
        3. Доп. поля:
            0. защитный код
            1. 8-мь байтов логических типов
            2. 8-мь байтов типизационных меток-битов
            3. Доп. описатель типов
            4. Инкрементный счётчик для анализа того, что структуру можно перемещать
                (дополнительный описатель многопоточных блокировок)
                Старший бит - запись в структуру
            5. Счётчик ссылок либо указатель на родительский объект
            6. Состояние (конечного автомата)
            7. Доп. зашитный код

4. Учёт всех объектов, имеющих состояние.
Состояния могут быть штатно изменены без последствий (например, вывод на консоль),
    а могут быть изменены с последствиями (например, цвет текста консоли).
    Эти изменения состояний должны различаться
    Задержки во времени также являются изменениями состояния (различных устройств)

5. Объекты должны быть с защитой. Например, что данный объект нельзя копировать,
т.к. он скоро будет удалён


6. При генерации программы должны быть специальные файлы для чтения - для проверки и изучения программы

7. Контейнеры выполнения: это штуки, в которых содержится данный объект.
    При закрытии контейнера мы автоматом должны убрать все структуры, выделенные для этого контейнера
    Контейнер позволяет нам отрабатывать доступ к объектам как будто они являются глобальными перемнными

8. Порядок выполнения указывается отдельно для функций, и отдельно для данных.
    Причём функции могут иметь несколько типов возврата, обработчики которых указываются отдельно
    Внешние объекты имеют свои логические описатели,
    которые позволяют указывать, что на них оказывается влияние

    Например, мы открываем файл и записываем в него дату и время
    args logFileName[r]                 // На аргументы по умолчанию не разрешены удаления
    vars now[c r] logFile[c w +]        // На внутренние переменные по умолчанию разрешено удаление
    Это может выглядеть либо как сводная таблица
    logFileName action state     now             action state   logFile action          state
    _           none    inited   _               none   null     _      none            null
    open        r       inited   DateTime.Now    c      inited   open   c               inited invalid
                                 write           r      inited   write  w               inited
    _           return  inited   return          d      deleted  close  close           inited.closed
                                                                 return d               invalid.deleted close.deleted

    Либо как отдельные горизонтальные таблицы
    logFileName
    func        _              open             return
    action      _              r                _
    from state  _              inited inwork    inwork
    state       inited inwork  inwork           inwork

        // Здесь явно нужны сокращения для того, чтобы поименовать сразу несколько состояний в одно

    now
                _       =_      _=       return
    action      _       c       r        d
    from state  _       null    inited   inwork
    state       null    inited  inwork   deleted

    Вот эта таблица может быть оптимизирована:
        её можно сделать стандартной, допустив использование в состоянии inited
    logFile
                _       open            return      write   close   return
    action      _       c               d           w       close   d
    from state  _       null            invalid     inited  inwork  closed
    state       null    inited invalid  deleted     inwork  closed  deleted

    Теперь как будет выглядеть функция
        now     = DateTime.Now
        logFile = open FileName: logFileName // Здесь мы можем опустить имя файла, ведь оно уже известно
        write file: logFile  data: now
        Обработка ошибки, наверное, может быть автоматической, так же как и вызов close

    Либо так:
        def now [r]
            DateTime.Now
        def logFile [r]
            > open
                FileName logFileName
                result
                    invalid invalid
                    inited  inited
        : invalid
            return  // автоматом del now logFile
        : inited
        > write
            File +      // + - оставляем автозаполнение
            data now    // Надо бы как-то разрешить здесь приведение типов
        > close
            File +
        return

    По хорошему, нужен ещё логический объект лог-файла logFileLO
        def now [r]
            DateTime.Now
        def logFile [r]
            > open          // В функции open должна быть связь между logFileLO и возвращаемым значением
                FileName logFileLO.logFileName
                result
                    invalid invalid
                    inited  inited
        : invalid
            return  // автоматом del now logFile
        : inited
        > write
            FileLO +
            File   +
            data   now    // Надо бы как-то разрешить здесь приведение типов
        > close
            FileLO +
            File +
        return

    Здесь было бы неплохо различать операции чтения ссылок и операции чтения самих структур
    Причём, было бы ещё неплохо различать чтение в целом и чтение по частям

    Операции было бы неплохо описывать даже так, чтобы можно было указать операции,
        которые будут вызываны уже в подфункциях,
        а также упрощённый порядок выполнения операций (например, без учёта условий, чтобы в каждом условии язык сам это всё проверял)


9. Необходимо запускать пользовательский код для того, чтобы можно было оценить типы и т.п.

10. Перемещение объектов для дефрагментации можно сделать как отдельную команду
    Потоки выставляют список объектов, которые блокируют
    Дефрагментатор выставляет объект, который переносит

Проверки на выход за пределы массивов могут быть отключены либо включены только один раз на цикл

11. Циклы

    foreach // просматривает всю коллекцию от начала до конца
    for index I: int [0 to length]    
        либо for index I [0 to length] или for index I [0 downto length] step 2 // step с проверкой переполнения
        цикл допускает декременты счётчика
    while
    do .. while
    repeat ... until

    Все циклы должны содержать else (если цикл не сработал ни разу)
    Все циклы содержат abort by N: возможность прекратить цикл, если он выполняется слишком много итераций

    goto допустим. Тоже должен содержать abort by N (счётчик циклов сбрасывается при входе в метку не из goto)

    Циклы могут содержать условные выходы
    mr foreach      // mr - multireturn
        Выражения
        if Выражения
            break found выражение_для_возврата_значения
        else
            Высказывания, если не было ни одной итерации
        : _
            Высказывания, если не сработал ни один break (если нет else, то если не было ни одной итерации, тоже сюда)
        : found
            Высказывания, если сработал break found // переменная found имеет значение возврата

    p foreach       // параллельный цикл, не допускает множественных возвратов



    Условия
        if
            multi   // Здесь будут сначала вычислены логические переменные, а потом уже условия
                Имя_Для_Условия_1
                    Условие1
                Имя_Для_Условия_2
                    Условие2
                Имя_Для_Условия_3
                    Условие3
            cond
                УсловноеВыражениеСИменами1
                    Высказывания // Команды
                УсловноеВыражениеСИменами2
                    Высказывания
                УсловноеВыражениеСИменами3
                    Высказывания
        либо
        if УсловноеВыражение
            Высказывания
        else
            Высказывания
        либо
        ife УсловноеВыражение
            Высказывания
        eif УсловноеВыражение
            Высказывания
        else
            Высказывания или _

        switch
            Условие
                Высказывание
                continue // Проваливаемся в следующее условие
            Условие
                Высказывание


12. Типизационная защита

    Если функция не имеет метки или имеет запрет на метку,
        значит, она не может быть выполнена с данной структурой
    Если функция имеет все метки (нестрогое надмножество), что и структура,
        значит она может быть выполнена с этой структурой

    Интерфейсы: объект/структура должен легко превращаться в интерфейс.
        В этом случае, программисту будут доступны функции именно этого интерфейса

13. Упрощённые записи для поиска по строкам
???? Может быть, более простое сопоставление с образцом

// Идём вперёд
> index [0 0] "http://"
    index+ [0 *] "@" not "?" "/" ":"
        Ошибка // Выявили http-авторизацию, которую мы, например, не поддерживаем
    index+ [0 0] not "?" "/" ":" : domain   // Поименовали данный захват как domain
        end
            Ошибка // Встретили неожиданный конец
        index+ [0 *] not "?" "/" ":" : domain // Всё ещё идёт в домен
            end
                return
    index+ [0 *] "?" "/" ":" : url


14. Возможность автоматического логирования входных и выходных параметров функций.
    Возможно, предусловий, постусловий и проверки инвариантов

    Все эти вещи нужно помечать метками, чтобы можно было включить только определённую группу проверок

15. Пометка параметров как stackalloc или как instack
        первый говорит, что можно использовать в объект стек для выделения;
        второй говорит о том, что можно использовать стек потока для выделения объекта

    ^:ИменованнаяСтрокаКода
    По имени именованной строки далее можно отработать, добавив туда ещё что-нибудь

16. Типы
    Адресная переменная (адрес)
        Нетипизированный объект типизируется статически
            простой адрес
                8 байтов - адрес
            защищённый адрес
                8 байтов - адрес
                8 байтов - защитный код
        Дополнительно, объект типизируется по тому, является ли он указателем на копию, или на оригинал (оригинал можно удалить).
            Оригинал можно ограничить только одним (это должна быть доп. типизация)
            Доп. статические типизации, в принципе, тоже могут быть, как указано в пункте 3.1
            При этом, объект должен как указывать, требует ли он данный тип или допускает данный тип (запрещает данный тип)
        Типизированный объект является полноценной структурой

17. Было бы неплохо отработать для vs-code завершение таких длинных манёвров, которые указаны выше
    https://github.com/microsoft/vscode-extension-samples/tree/main/completions-sample


18. Необходимо, чтобы типы могли сразу же содержать все необходимые классы эквивалентности,
        чтобы их можно было проверять. Это должно быть статически типизировано
            и пользователь должен принуждаться проверять все классы эквивалентности
            либо должны быть проверки на то, что проверки на классы эквивалентности не нужны

